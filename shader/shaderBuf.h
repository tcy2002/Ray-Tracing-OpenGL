#pragma once

#define tracer_vert "#version 330\r\n\r\nlayout (location = 1) in vec3 aPosition;\r\n\r\nout vec3 position;\r\n\r\nvoid main() {\r\n    position = aPosition;\r\n    gl_Position = vec4(aPosition, 1.0);\r\n}"

#define tracer_frag "#version 330\r\n\r\n#define PI 3.1415926\r\n#define INF 114514.0\r\n#define ERR 0.0001\r\n\r\nin vec3 position;\r\nout vec4 FragColor;\r\n\r\n//\xe5\xb1\x8f\xe5\xb9\x95\xe5\x8f\x82\xe6\x95\xb0\r\nuniform int width;\r\nuniform int height;\r\nvec2 pixel2d = vec2(2.0 / width, 2.0 / height);\r\n\r\n//\xe5\xb8\xa7\xe6\x95\xb0\r\nuniform int frame;\r\nuniform int maxFrame;\r\nuniform int iter;\r\n\r\n//\xe4\xb8\x8a\xe4\xb8\x80\xe5\xb8\xa7\xe7\x9a\x84\xe5\xb8\xa7\xe7\xbc\x93\xe5\xad\x98\r\nuniform sampler2D lastFrame;\r\n\r\n//\xe8\xa7\x86\xe7\x82\xb9\r\nuniform vec3 eyePos;\r\n\r\n//\xe8\xa1\xa8\xe9\x9d\xa2\xe6\x9d\x90\xe8\xb4\xa8\xef\xbc\x9a\xe5\x8f\x82\xe8\x80\x83material.h\r\nstruct Material {\r\n    bool lighting;\r\n    vec3 color;\r\n    float specularRate;\r\n    float specularTint;\r\n    float specularRoughness;\r\n    float refractRate;\r\n    float refractTint;\r\n    float refractIndex;\r\n    float refractRoughness;\r\n};\r\n\r\n//`BVH`\xe6\xa0\x91\xe8\x8a\x82\xe7\x82\xb9\r\nstruct BVHNode {\r\n    vec3 AA;\r\n    vec3 BB;\r\n    int l;\r\n    int r;\r\n    int n;\r\n    int index;\r\n};\r\n\r\n/*****************************************************\r\n * \xe6\xa8\xa1\xe5\x9e\x8b\xe5\xae\x9a\xe4\xb9\x89\r\n *****************************************************/\r\n\r\n//\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\r\nstruct Quad {\r\n    vec3 samples[4];\r\n    vec3 normal;\r\n};\r\n\r\n//\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\xe6\xa8\xa1\xe5\x9e\x8b\r\nstruct QuadModel {\r\n    Quad quad;\r\n    Material material;\r\n    bool useTexture;\r\n    sampler2D texture;\r\n};\r\n\r\n//\xe7\x90\x83\xe4\xbd\x93\r\nstruct Sphere {\r\n    vec3 center;\r\n    float radius;\r\n};\r\n\r\n//\xe7\x90\x83\xe4\xbd\x93\xe6\xa8\xa1\xe5\x9e\x8b\r\nstruct SphereModel {\r\n    Sphere sph;\r\n    Material material;\r\n    bool useTexture;\r\n    sampler2D texture;\r\n};\r\n\r\n//\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\r\nstruct Cylinder {\r\n    vec3 center;\r\n    float radius;\r\n    float height;\r\n};\r\n\r\n//\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\xe6\xa8\xa1\xe5\x9e\x8b\r\nstruct CylinderModel {\r\n    Cylinder cyl;\r\n    Material material;\r\n    bool useTexture;\r\n    sampler2D texture;\r\n};\r\n\r\n//\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b\r\nstruct CustomizedModel {\r\n    samplerBuffer patchTex;\r\n    samplerBuffer bvhTex;\r\n    vec3 center;\r\n    float height;\r\n    Material material;\r\n    bool useTexture;\r\n    sampler2D texture;\r\n};\r\n\r\n/*****************************************************/\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\r\nstruct Ray {\r\n    vec3 startPoint;\r\n    vec3 direction;\r\n};\r\n\r\n//\xe5\x87\xbb\xe4\xb8\xad\xe4\xbf\xa1\xe6\x81\xaf\r\nstruct HitInfo {\r\n    float distance;         // \xe4\xb8\x8e\xe4\xba\xa4\xe7\x82\xb9\xe7\x9a\x84\xe8\xb7\x9d\xe7\xa6\xbb\r\n    vec3 hitPoint;          // \xe5\x85\x89\xe7\xba\xbf\xe5\x91\xbd\xe4\xb8\xad\xe7\x82\xb9\r\n    vec3 normal;            // \xe5\x91\xbd\xe4\xb8\xad\xe7\x82\xb9\xe6\xb3\x95\xe7\xba\xbf\r\n    vec3 viewDir;           // \xe5\x87\xbb\xe4\xb8\xad\xe8\xaf\xa5\xe7\x82\xb9\xe7\x9a\x84\xe5\x85\x89\xe7\xba\xbf\xe7\x9a\x84\xe6\x96\xb9\xe5\x90\x91\r\n    Material material;      // \xe5\x91\xbd\xe4\xb8\xad\xe7\x82\xb9\xe7\x9a\x84\xe8\xa1\xa8\xe9\x9d\xa2\xe6\x9d\x90\xe8\xb4\xa8\r\n};\r\n\r\n//\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xbf\xa1\xe6\x81\xaf\r\nuniform int quadNum;\r\nuniform QuadModel quads[8];        //\xe6\x9c\x80\xe5\xa4\x9a\xe5\x85\xab\xe4\xb8\xaa\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\r\nuniform int sphereNum;\r\nuniform SphereModel spheres[3];    //\xe6\x9c\x80\xe5\xa4\x9a\xe4\xb8\x89\xe4\xb8\xaa\xe7\x90\x83\r\nuniform int cylinderNum;\r\nuniform CylinderModel cylinders[3];//\xe6\x9c\x80\xe5\xa4\x9a\xe4\xb8\x89\xe4\xb8\xaa\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\r\nuniform CustomizedModel customized;//\xe4\xbb\x85\xe6\x94\xaf\xe6\x8c\x81\xe4\xb8\x80\xe4\xb8\xaa\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b\r\n\r\n/*****************************************************\r\n * \xe7\x94\x9f\xe6\x88\x90\xe9\x9a\x8f\xe6\x9c\xba\xe6\x95\xb0\xef\xbc\x9a\xe9\x9a\x8f\xe6\x9c\xba\xe7\xa7\x8d\xe5\xad\x90+\xe5\x93\x88\xe5\xb8\x8c\r\n *****************************************************/\r\n\r\n//\xe9\x9a\x8f\xe6\x9c\xba\xe7\xa7\x8d\xe5\xad\x90\r\nuint seed = uint(\r\n    uint((position.x * 0.5 + 0.5) * width) * 1973u +\r\n    uint((position.y * 0.5 + 0.5) * height) * 9277u +\r\n    uint(frame + iter * maxFrame) * 26699u);\r\n\r\n//\xe5\x93\x88\xe5\xb8\x8c\xe5\x87\xbd\xe6\x95\xb0\r\nuint hash(inout uint seed) {\r\n    seed *= 0x27d4eb2du;\r\n    seed = seed ^ (seed >> 15);\r\n    return seed;\r\n}\r\n\r\n//\xe9\x9a\x8f\xe6\x9c\xba\xe6\x95\xb0\r\nfloat rand() {\r\n    return float(hash(seed)) / 4294967296.0;\r\n}\r\n\r\n/*****************************************************\r\n * sobol\xe5\xba\x8f\xe5\x88\x97\r\n *****************************************************/\r\n\r\nuniform uint V[64];\r\n\r\n//\xe4\xbb\x85\xe4\xb8\x8e\xe5\x83\x8f\xe7\xb4\xa0\xe5\x9d\x90\xe6\xa0\x87\xe6\x9c\x89\xe5\x85\xb3\xe7\x9a\x84\xe9\x9a\x8f\xe6\x9c\xba\xe7\xa7\x8d\xe5\xad\x90\r\nuint pseed = uint(\r\n    uint((position.x * 0.5 + 0.5) * width) * 1973u +\r\n    uint((position.y * 0.5 + 0.5) * height) * 9277u +\r\n    512u * 26699u);\r\n\r\n//\xe6\xa0\xbc\xe6\x9e\x97\xe7\xa0\x81\r\nint gray = frame ^ (frame >> 1);\r\n\r\n//\xe7\x94\x9f\xe6\x88\x90`sobol`\xe6\x95\xb0\r\nfloat sobol(int d, int i) {\r\n    uint result = 0u;\r\n    int offset = d * 32;\r\n    for (int j = 0, k = i; k != 0; k >>= 1, j++) {\r\n        if ((k & 1) == 1) {\r\n            result ^= V[j + offset];\r\n        }\r\n    }\r\n    return float(result) / 4294967296.0;\r\n}\r\n\r\nfloat CranleyPattersonRotation(float p) {\r\n    float u = float(hash(pseed)) / 4294967296.0;\r\n    p += u;\r\n    if(p > 1.0) p -= 1.0;\r\n    if(p < 0.0) p += 1.0;\r\n    return p;\r\n}\r\n\r\n/*****************************************************\r\n * \xe7\x94\x9f\xe6\x88\x90\xe9\x9a\x8f\xe6\x9c\xba\xe5\x90\x91\xe9\x87\x8f\r\n *****************************************************/\r\n\r\n//\xe5\xb0\x86\xe5\x90\x91\xe9\x87\x8fv\xe6\x8a\x95\xe5\xbd\xb1\xe5\x88\xb0N\xe7\x9a\x84\xe6\xb3\x95\xe5\x90\x91\xe5\x8d\x8a\xe7\x90\x83\r\nvec3 toNormalHemisphere(vec3 v, vec3 N) {\r\n    vec3 helper = vec3(1.0, 0.0, 0.0);\r\n    if(abs(N.x) >= 1.0 - ERR) helper = vec3(0.0, 0.0, 1.0);\r\n    vec3 tangent = normalize(cross(N, helper));\r\n    vec3 bitangent = normalize(cross(N, tangent));\r\n    return v.x * tangent + v.y * bitangent + v.z * N;\r\n}\r\n\r\n//\xe6\xb3\x95\xe5\x90\x91\xe5\x8d\x8a\xe7\x90\x83\xe9\x9a\x8f\xe6\x9c\xba\xe9\x87\x87\xe6\xa0\xb7\r\nvec3 sampleHemisphere(vec3 N) {\r\n    float r = sqrt(rand());\r\n    float t = rand() * (2.0 * PI);\r\n    float x = r * cos(t);\r\n    float y = r * sin(t);\r\n    float z = sqrt(1.0 - x * x - y * y);\r\n    return toNormalHemisphere(vec3(x, y, z), N);\r\n}\r\n\r\n//\xe6\xa0\xb9\xe6\x8d\xaesobol\xe5\xba\x8f\xe5\x88\x97\xe7\x9a\x84\xe5\x9d\x87\xe5\x8c\x80\xe5\x8d\x8a\xe7\x90\x83\xe9\x87\x87\xe6\xa0\xb7\r\nvec3 sampleSobolHemisphere(vec3 N) {\r\n    float u = CranleyPattersonRotation(sobol(0, gray));\r\n    float v = CranleyPattersonRotation(sobol(1, gray));\r\n//    float u = sobol(0, gray);\r\n//    float v = sobol(1, gray);\r\n    float r = sqrt(u);\r\n    float t = v * (2.0 * PI);\r\n    float x = r * cos(t);\r\n    float y = r * sin(t);\r\n    float z = sqrt(1.0 - x * x - y * y);\r\n    return toNormalHemisphere(vec3(x, y, z), N);\r\n}\r\n\r\n/*****************************************************\r\n * \xe5\x85\x89\xe7\xba\xbf\xe8\xbf\xbd\xe8\xb8\xaa\r\n *****************************************************/\r\n\r\n//\xe7\x82\xb9\xe5\x9d\x90\xe6\xa0\x87\xe5\x88\xb0\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\xe7\xba\xb9\xe7\x90\x86\xe5\x9d\x90\xe6\xa0\x87\xe7\x9a\x84\xe6\x98\xa0\xe5\xb0\x84\r\nvec2 quadTexCoord(in vec3 samples[4], vec3 P) {\r\n    vec3 m = samples[2] - samples[0];\r\n    vec3 n = samples[0] - samples[1];\r\n    vec3 q = P - samples[1];\r\n    if (m.x == 0.0 && n.x == 0.0 && q.x == 0) {\r\n        mat2 mn = mat2(m.yz, n.yz);\r\n        return inverse(mn) * q.yz;\r\n    }\r\n    if (m.y == 0.0 && n.y == 0.0 && q.y == 0.0) {\r\n        mat2 mn = mat2(m.xz, n.xz);\r\n        return inverse(mn) * q.xz;\r\n    }\r\n    mat2 mn = mat2(m.xy, n.xy);\r\n    return inverse(mn) * n.xy;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\r\nbool hitQuad(Ray r, in Quad quad, inout HitInfo hit) {\r\n    //\xe6\xb1\x82\xe5\x85\x89\xe7\xba\xbf\xe4\xb8\x8e\xe5\xb9\xb3\xe9\x9d\xa2\xe4\xba\xa4\xe7\x82\xb9\r\n    vec3 n1 = quad.samples[1] - quad.samples[0];\r\n    vec3 n2 = quad.samples[2] - quad.samples[0];\r\n    vec3 normal = normalize(cross(n1, n2));\r\n    float d = -dot(quad.samples[0], normal);\r\n    float m = dot(r.direction, normal);\r\n    if (m >= -ERR) return false; //\xe5\x89\x94\xe9\x99\xa4\xe8\x83\x8c\xe5\x90\x91\xe9\x9d\xa2\r\n    float t = -(d + dot(r.startPoint, normal)) / m;\r\n    if (t <= ERR) return false; //\xe5\x89\x94\xe9\x99\xa4\xe4\xb8\x8e\xe8\x87\xaa\xe8\xba\xab\xe7\x9b\xb8\xe4\xba\xa4\xe7\x9a\x84\xe6\x83\x85\xe5\x86\xb5\r\n    vec3 P = r.startPoint + r.direction * t;\r\n\r\n    //\xe6\xa0\xb9\xe6\x8d\xae\xe5\x8f\x89\xe4\xb9\x98\xe4\xb8\x8e\xe6\xb3\x95\xe7\x9f\xa2\xe9\x87\x8f\xe7\x9a\x84\xe6\x96\xb9\xe5\x90\x91\xe5\x85\xb3\xe7\xb3\xbb\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x90\xa6\xe5\x9c\xa8\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\xe5\x86\x85\r\n    vec3 n3 = P - quad.samples[0];\r\n    vec3 n4 = P - quad.samples[1];\r\n    vec3 n5 = P - quad.samples[2];\r\n    float f1 = dot(cross(n1, n3), normal);\r\n    float f2 = dot(cross(n3, n2), normal);\r\n    float f3 = dot(cross(n5, n1), normal);\r\n    float f4 = dot(cross(n2, n4), normal);\r\n\r\n    if (f1 > -ERR && f2 > -ERR && f3 > -ERR && f4 > -ERR && t < hit.distance - ERR) {\r\n        hit.distance = t;\r\n        hit.hitPoint = P;\r\n        hit.viewDir = r.direction;\r\n        hit.normal = normal;\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe5\x9b\x9b\xe8\xbe\xb9\xe5\xbd\xa2\xe6\xa8\xa1\xe5\x9e\x8b\r\nbool hitQuadModel(Ray r, in QuadModel quadM, inout HitInfo hit) {\r\n    bool ret = hitQuad(r, quadM.quad, hit);\r\n    if (ret) {\r\n        hit.material = quadM.material;\r\n        //\xe7\xba\xb9\xe7\x90\x86\xe6\x98\xa0\xe5\xb0\x84\r\n        if (quadM.useTexture) {\r\n            vec2 tex = quadTexCoord(quadM.quad.samples, hit.hitPoint);\r\n            vec3 color = texture2D(quadM.texture, tex).rgb;\r\n            hit.material.color = color;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe7\x90\x83\xe4\xbd\x93\r\nbool hitSphere(Ray r, in Sphere sphere, inout HitInfo hit) {\r\n    //\xe8\xae\xa1\xe7\xae\x97\xe5\x85\x89\xe7\xba\xbf\xe4\xb8\x8e\xe7\x90\x83\xe5\xbf\x83\xe8\xb7\x9d\xe7\xa6\xbb\r\n    float t = dot(sphere.center - r.startPoint, r.direction);\r\n    vec3 T = r.startPoint + r.direction * t;\r\n    vec3 CP = T - sphere.center;\r\n    float l_CP = length(CP);\r\n\r\n    //\xe8\xb7\x9d\xe7\xa6\xbb\xe5\xa4\xa7\xe4\xba\x8e\xe5\x8d\x8a\xe5\xbe\x84\xe5\x88\x99\xe4\xb8\x8d\xe7\x9b\xb8\xe4\xba\xa4\r\n    if (l_CP > sphere.radius) return false;\r\n\r\n    //\xe8\xae\xa1\xe7\xae\x97\xe4\xba\xa4\xe7\x82\xb9\r\n    float delta = sqrt(sphere.radius * sphere.radius - l_CP * l_CP);\r\n    float t1 = t - delta;\r\n    float t2 = t + delta;\r\n\r\n    //\xe5\x88\xa4\xe6\x96\xad\xe6\x98\xaf\xe5\x93\xaa\xe4\xb8\xaa\xe4\xba\xa4\xe7\x82\xb9\xef\xbc\x8c\xe5\xb9\xb6\xe5\x89\x94\xe9\x99\xa4\xe4\xb8\x8e\xe8\x87\xaa\xe8\xba\xab\xe7\x9b\xb8\xe4\xba\xa4\xe7\x9a\x84\xe6\x83\x85\xe5\x86\xb5\r\n    if (t1 > ERR) t = t1;\r\n    else if (t2 > ERR) t = t2;\r\n    else return false;\r\n\r\n    //\xe5\xad\x98\xe5\x9c\xa8\xe9\x81\xae\xe6\x8c\xa1\r\n    if (t >= hit.distance - ERR) return false;\r\n\r\n    hit.distance = t;\r\n    hit.hitPoint = r.startPoint + r.direction * t;\r\n    hit.normal = normalize(hit.hitPoint - sphere.center);\r\n    hit.viewDir = r.direction;\r\n    return true;\r\n}\r\n\r\n//\xe6\xb3\x95\xe7\x9f\xa2\xe9\x87\x8f\xe5\x88\xb0\xe7\x90\x83\xe9\x9d\xa2\xe7\xba\xb9\xe7\x90\x86\xe5\x9d\x90\xe6\xa0\x87\xe7\x9a\x84\xe6\x98\xa0\xe5\xb0\x84\r\nvec2 sphereTexCoord(vec3 N) {\r\n    float ang_x = atan(N.z, N.x);\r\n    float ang_y = asin(N.y);\r\n    vec2 uv = vec2(ang_x, ang_y);\r\n    uv.x = 1.0 - ang_x / (2.0 * PI);\r\n    uv.y = 0.5 + ang_y / PI;\r\n    return uv;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe7\x90\x83\xe4\xbd\x93\xe6\xa8\xa1\xe5\x9e\x8b\r\nbool hitSphereModel(Ray r, in SphereModel sphM, inout HitInfo hit) {\r\n    bool ret = hitSphere(r, sphM.sph, hit);\r\n    if (ret) {\r\n        hit.material = sphM.material;\r\n        //\xe7\xba\xb9\xe7\x90\x86\xe6\x98\xa0\xe5\xb0\x84\r\n        if (sphM.useTexture) {\r\n            vec2 texc = sphereTexCoord(hit.normal);\r\n            vec3 color = texture2D(sphM.texture, texc).rgb;\r\n            hit.material.color = color;\r\n        }\r\n        //\xe6\x8a\x98\xe5\xb0\x84\xe7\x8e\x87\xef\xbc\x9a\xe5\xb0\x84\xe5\x87\xba\xe6\x97\xb6\xe9\x9c\x80\xe8\xa6\x81\xe5\x8f\x96\xe5\x80\x92\xe6\x95\xb0\r\n        float ref_ang = hit.material.refractIndex;\r\n        if (ref_ang != 0 && dot(hit.normal, r.direction) > 0) {\r\n            hit.material.refractIndex = 1.0 / ref_ang;\r\n            hit.normal = -hit.normal;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\r\nbool hitCylinder(Ray r, in Cylinder cyl, inout HitInfo hit) {\r\n    //\xe8\xae\xa1\xe7\xae\x97\xe5\x85\x89\xe7\xba\xbf\xe5\x88\xb0\xe4\xb8\xad\xe8\xbd\xb4\xe7\x9a\x84\xe6\x9c\x80\xe7\x9f\xad\xe8\xb7\x9d\xe7\xa6\xbb\r\n    vec2 SF = cyl.center.xz - r.startPoint.xz;\r\n    vec2 d_ST = r.direction.xz;\r\n    float l_FT = abs(SF.y * d_ST.x - SF.x * d_ST.y) / length(d_ST);\r\n\r\n    //\xe8\xb7\x9d\xe7\xa6\xbb\xe5\xa4\xa7\xe4\xba\x8e\xe5\x8d\x8a\xe5\xbe\x84\xe5\x88\x99\xe4\xb8\x8d\xe4\xb8\x8e\xe6\x97\xa0\xe9\x99\x90\xe9\x95\xbf\xe5\x9c\x86\xe6\x9f\xb1\xe9\x9d\xa2\xe7\x9b\xb8\xe4\xba\xa4\r\n    if (l_FT > cyl.radius) return false;\r\n\r\n    //\xe8\xae\xa1\xe7\xae\x97\xe4\xb8\x8e\xe6\x97\xa0\xe9\x99\x90\xe9\x95\xbf\xe5\x9c\x86\xe6\x9f\xb1\xe9\x9d\xa2\xe7\x9a\x84\xe4\xba\xa4\xe7\x82\xb9\r\n    float l_SF = length(SF);\r\n    float t = sqrt(l_SF * l_SF - l_FT * l_FT) / length(d_ST);\r\n    float right = cyl.radius * cyl.radius - l_FT * l_FT;\r\n    float left = 1.0 - r.direction.y * r.direction.y;\r\n    float delta = sqrt(right / left);\r\n    float t1 = t - delta;\r\n    float t2 = t + delta;\r\n    vec3 M = r.startPoint + r.direction * t1;\r\n    vec3 N = r.startPoint + r.direction * t2;\r\n\r\n    //\xe4\xba\xa4\xe7\x82\xb9\xe6\x96\xb9\xe5\x90\x91\xe7\x9b\xb8\xe5\x8f\x8d\r\n    if (t2 <= ERR) return false;\r\n\r\n    //\xe5\x87\xbb\xe4\xb8\xad\xe7\x82\xb9\xe5\x9c\xa8M\r\n    if (M.y >= cyl.center.y && M.y <= cyl.center.y + cyl.height) {\r\n        if (t1 <= ERR) return false; //\xe4\xb8\x8e\xe8\x87\xaa\xe8\xba\xab\xe7\x9b\xb8\xe4\xba\xa4\r\n        if (t1 >= hit.distance - ERR) return false; //\xe5\xad\x98\xe5\x9c\xa8\xe9\x81\xae\xe6\x8c\xa1\r\n        vec2 nor = normalize(M.xz - cyl.center.xz);\r\n        hit.distance = t1;\r\n        hit.hitPoint = M;\r\n        hit.normal = vec3(nor.x, 0.0, nor.y);\r\n        hit.viewDir = r.direction;\r\n        return true;\r\n    }\r\n\r\n    //\xe5\x87\xbb\xe4\xb8\xad\xe7\x82\xb9\xe5\x9c\xa8\xe4\xb8\x8b\xe5\xba\x95\xe9\x9d\xa2\r\n    if (M.y < cyl.center.y && N.y >= cyl.center.y) {\r\n        float m = (cyl.center.y - r.startPoint.y) / r.direction.y;\r\n        if (m >= hit.distance - ERR) return false; //\xe5\xad\x98\xe5\x9c\xa8\xe9\x81\xae\xe6\x8c\xa1\r\n        hit.distance = m;\r\n        hit.hitPoint = r.startPoint + r.direction * m;\r\n        hit.normal = vec3(0.0, -1.0, 0.0);\r\n        hit.viewDir = r.direction;\r\n        return true;\r\n    }\r\n\r\n    //\xe5\x87\xbb\xe4\xb8\xad\xe7\x82\xb9\xe5\x9c\xa8\xe4\xb8\x8a\xe5\xba\x95\xe9\x9d\xa2\r\n    if (M.y > cyl.center.y + cyl.height && N.y <= cyl.center.y + cyl.height) {\r\n        float m = (cyl.center.y + cyl.height - r.startPoint.y) / r.direction.y;\r\n        if (m >= hit.distance - ERR) return false; //\xe5\xad\x98\xe5\x9c\xa8\xe9\x81\xae\xe6\x8c\xa1\r\n        hit.distance = m;\r\n        hit.hitPoint = r.startPoint + r.direction * m;\r\n        hit.normal = vec3(0.0, 1.0, 0.0);\r\n        hit.viewDir = r.direction;\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//\xe7\x82\xb9\xe5\x9d\x90\xe6\xa0\x87\xe5\x88\xb0\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\xe4\xbe\xa7\xe9\x9d\xa2\xe7\x9a\x84\xe7\xba\xb9\xe7\x90\x86\xe6\x98\xa0\xe5\xb0\x84\r\nvec2 cylinderTexCoord(vec3 P, vec3 center, float height) {\r\n    float ang_x = atan(P.z - center.z, P.x - center.x);\r\n    vec2 uv;\r\n    uv.x = 1.0 - ang_x / (2.0 * PI);\r\n    uv.y = (P.y - center.y) / height;\r\n    return uv;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\xe6\xa8\xa1\xe5\x9e\x8b\r\nbool hitCylinderModel(Ray r, in CylinderModel cylM, inout HitInfo hit) {\r\n    bool ret = hitCylinder(r, cylM.cyl, hit);\r\n    if (ret) {\r\n        hit.material = cylM.material;\r\n        hit.material.refractRate = 0.0; //\xe5\x9c\x86\xe6\x9f\xb1\xe4\xbd\x93\xe4\xb8\x8d\xe6\x94\xaf\xe6\x8c\x81\xe9\x80\x8f\xe6\x98\x8e\xe6\x9d\x90\xe8\xb4\xa8\r\n        float y = hit.hitPoint.y;\r\n        float y_l = cylM.cyl.center.y;\r\n        float y_h = y_l + cylM.cyl.height;\r\n        //\xe5\x8f\xaa\xe6\x9c\x89\xe4\xbe\xa7\xe9\x9d\xa2\xe6\x9c\x89\xe7\xba\xb9\xe7\x90\x86\xe6\x98\xa0\xe5\xb0\x84\r\n        if (cylM.useTexture && y > y_l && y < y_h) {\r\n            vec2 tex = cylinderTexCoord(hit.hitPoint, cylM.cyl.center, cylM.cyl.height);\r\n            vec3 color = texture2D(cylM.texture, tex).rgb;\r\n            hit.material.color = color;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n\r\n//\xe8\x8e\xb7\xe5\x8f\x96\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b\xe9\x9d\xa2\xe7\x89\x87\xe6\x95\xb0\xe6\x8d\xae\r\nQuad getPatch(int i) {\r\n    int offset = i * 5;\r\n    Quad q;\r\n\r\n    q.samples[0] = texelFetch(customized.patchTex, offset).xyz;\r\n    q.samples[1] = texelFetch(customized.patchTex, offset + 1).xyz;\r\n    q.samples[2] = texelFetch(customized.patchTex, offset + 2).xyz;\r\n    q.samples[3] = texelFetch(customized.patchTex, offset + 3).xyz;\r\n    q.normal = texelFetch(customized.patchTex, offset + 4).xyz;\r\n\r\n    return q;\r\n}\r\n\r\n//\xe8\x8e\xb7\xe5\x8f\x96\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b`BVH`\xe6\xa0\x91\xe8\x8a\x82\xe7\x82\xb9\xe6\x95\xb0\xe6\x8d\xae\r\nBVHNode getBVH(int i) {\r\n    int offset = i * 4;\r\n    BVHNode n;\r\n\r\n    n.AA = texelFetch(customized.bvhTex, offset).xyz;\r\n    n.BB = texelFetch(customized.bvhTex, offset + 1).xyz;\r\n    ivec3 tmp = ivec3(texelFetch(customized.bvhTex, offset + 2).xyz);\r\n    n.l = tmp.x;\r\n    n.r = tmp.y;\r\n    tmp = ivec3(texelFetch(customized.bvhTex, offset + 3).xyz);\r\n    n.n = tmp.x;\r\n    n.index = tmp.y;\r\n\r\n    return n;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad`AABB`\xe5\x8c\x85\xe5\x9b\xb4\xe7\x9b\x92\r\nfloat hitAABB(Ray r, vec3 AA, vec3 BB) {\r\n    vec3 M = (BB - r.startPoint) / r.direction;\r\n    vec3 N = (AA - r.startPoint) / r.direction;\r\n\r\n    vec3 tmax = max(M, N);\r\n    vec3 tmin = min(M, N);\r\n\r\n    float t1 = min(tmax.x, min(tmax.y, tmax.z));\r\n    float t2 = max(tmin.x, max(tmin.y, tmin.z));\r\n\r\n    return t1 >= t2 && t2 > ERR ? t2 : -1.0;\r\n}\r\n\r\n//\xe5\x85\x89\xe7\xba\xbf\xe6\x98\xaf\xe5\x90\xa6\xe5\x87\xbb\xe4\xb8\xad\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b\r\nbool hitCustomizedModel(Ray r, inout HitInfo hit) {\r\n    int stack[8];\r\n    int p = 0;\r\n\r\n    stack[p++] = 0;\r\n    while (p > 0) {\r\n        int top = stack[--p];\r\n        BVHNode node = getBVH(top);\r\n\r\n        //\xe5\x8f\xb6\xe5\xad\x90\xe7\xbb\x93\xe7\x82\xb9\r\n        if (node.n > 0) {\r\n            int m = node.index;\r\n            int n = m + node.n;\r\n            for (int i = m; i < n; i++) {\r\n                Quad q = getPatch(i);\r\n                if (hitQuad(r, q, hit)) {\r\n                    hit.material = customized.material;\r\n                    hit.material.refractRate = 0.0; //\xe8\x87\xaa\xe5\xae\x9a\xe4\xb9\x89\xe6\xa8\xa1\xe5\x9e\x8b\xe4\xb8\x8d\xe6\x94\xaf\xe6\x8c\x81\xe9\x80\x8f\xe6\x98\x8e\xe6\x9d\x90\xe8\xb4\xa8\r\n                    //\xe7\xba\xb9\xe7\x90\x86\xe6\x98\xa0\xe5\xb0\x84\r\n                    if (customized.useTexture) {\r\n                        vec2 tex = cylinderTexCoord(hit.hitPoint, customized.center, customized.height);\r\n                        vec3 color = texture2D(customized.texture, tex).rgb;\r\n                        hit.material.color = color;\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        //\xe4\xb8\x8e\xe5\xb7\xa6\xe5\x8f\xb3\xe7\x9b\x92\xe5\xad\x90\xe6\xb1\x82\xe4\xba\xa4\r\n        float t1 = -1.0, t2 = -1.0;\r\n        if (node.l >= 0) {\r\n            BVHNode l_node = getBVH(node.l);\r\n            t1 = hitAABB(r, l_node.AA, l_node.BB);\r\n        }\r\n        if (node.r >= 0) {\r\n            BVHNode r_node = getBVH(node.r);\r\n            t2 = hitAABB(r, r_node.AA, r_node.BB);\r\n        }\r\n\r\n        //\xe5\x9c\xa8\xe6\x9c\x80\xe8\xbf\x91\xe7\x9a\x84\xe7\x9b\x92\xe5\xad\x90\xe4\xb8\xad\xe6\x90\x9c\xe7\xb4\xa2\r\n        if (t1 > 0 && t2 > 0) {\r\n            if (t1 < t2) {\r\n                stack[p++] = node.r;\r\n                stack[p++] = node.l;\r\n            } else {\r\n                stack[p++] = node.l;\r\n                stack[p++] = node.r;\r\n            }\r\n        } else if (t1 > 0) {\r\n            stack[p++] = node.l;\r\n        } else if (t2 > 0) {\r\n            stack[p++] = node.r;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n//\xe5\x87\xbb\xe4\xb8\xad\xe5\x88\xa4\xe6\x96\xad\r\nbool hitModel(Ray r, out HitInfo hit) {\r\n    hit.distance = INF;\r\n    bool ret = false;\r\n\r\n    for (int i = 0; i < cylinderNum; i++) {\r\n        ret = hitCylinderModel(r, cylinders[i], hit) || ret;\r\n    }\r\n    for (int i = 0; i < quadNum; i++) {\r\n        ret = hitQuadModel(r, quads[i], hit) || ret;\r\n    }\r\n    for (int i = 0; i < sphereNum; i++) {\r\n        ret = hitSphereModel(r, spheres[i], hit) || ret;\r\n    }\r\n    ret = hitCustomizedModel(r, hit) || ret;\r\n\r\n    return ret;\r\n}\r\n\r\n//\xe8\xb7\xaf\xe5\xbe\x84\xe8\xbf\xbd\xe8\xb8\xaa\xef\xbc\x9a\xe7\xba\xbf\xe6\x80\xa7\xe5\x8c\x96\xe9\x80\x92\xe5\xbd\x92\r\nvec3 pathTracing(Ray r, int maxDepth) {\r\n    if (maxDepth > 8) maxDepth = 8; //\xe6\x9c\x80\xe5\xa4\x9a\xe9\x80\x92\xe5\xbd\x92\xe5\x85\xab\xe5\xb1\x82\r\n    vec3 color[8];   //\xe8\xae\xb0\xe5\xbd\x95\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb1\x82\xe9\x80\x92\xe5\xbd\x92\xe7\x9a\x84\xe5\x9f\xba\xe7\xa1\x80\xe9\xa2\x9c\xe8\x89\xb2\r\n    int type[8];     //\xe8\xae\xb0\xe5\xbd\x95\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb1\x82\xe9\x80\x92\xe5\xbd\x92\xe7\x9a\x84\xe5\x85\x89\xe7\xba\xbf\xe7\xb1\xbb\xe5\x9e\x8b\r\n    float cosine[8]; //\xe8\xae\xb0\xe5\xbd\x95\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb1\x82\xe9\x80\x92\xe5\xbd\x92\xe7\x9a\x84\xe5\xa4\xb9\xe8\xa7\x92\xe4\xbd\x99\xe5\xbc\xa6\r\n    float tint[8];   //\xe8\xae\xb0\xe5\xbd\x95\xe6\xaf\x8f\xe4\xb8\x80\xe5\xb1\x82\xe9\x80\x92\xe5\xbd\x92\xe7\x9a\x84\xe6\xb7\xb7\xe5\x90\x88\xe6\x8c\x87\xe6\x95\xb0\r\n    int depth;\r\n\r\n    for (depth = 0; depth < maxDepth; depth++) {\r\n        //\xe8\x8b\xa5\xe6\x9c\xaa\xe5\x87\xbb\xe4\xb8\xad\xe5\x88\x99\xe7\x9b\xb4\xe6\x8e\xa5\xe8\xbf\x94\xe5\x9b\x9e\r\n        HitInfo hit;\r\n        if (!hitModel(r, hit)) {\r\n            color[depth] = vec3(0.0);\r\n            break;\r\n        }\r\n\r\n        //\xe5\x8f\x8d\xe4\xbc\xbd\xe9\xa9\xac\xe6\xa0\xa1\xe6\xad\xa3\r\n        color[depth] = pow(hit.material.color, vec3(2.2));\r\n//        color[depth] = hit.material.color;\r\n\r\n        //\xe8\x8b\xa5\xe5\x87\xbb\xe4\xb8\xad\xe5\x85\x89\xe6\xba\x90\xe5\x88\x99\xe8\xbf\x94\xe5\x9b\x9e\r\n        if (hit.material.lighting) break;\r\n\r\n        //\xe5\x85\x89\xe7\xba\xbf\xe4\xb8\x8e\xe5\x87\xbb\xe4\xb8\xad\xe7\x82\xb9\xe6\xb3\x95\xe7\x9f\xa2\xe9\x87\x8f\xe7\x9a\x84\xe5\xa4\xb9\xe8\xa7\x92\xe4\xbd\x99\xe5\xbc\xa6\r\n        cosine[depth] = abs(dot(hit.normal, r.direction));\r\n\r\n        //\xe9\x9a\x8f\xe6\x9c\xba\xe7\x94\x9f\xe6\x88\x90\xe4\xb8\x8b\xe4\xb8\x80\xe6\x9d\xa1\xe5\x85\x89\xe7\xba\xbf\r\n        vec3 oldRay = r.direction;\r\n        r.direction = depth == 0 ? sampleSobolHemisphere(hit.normal) : sampleHemisphere(hit.normal);\r\n//        r.direction = sampleHemisphere(hit.normal);\r\n        r.startPoint = hit.hitPoint;\r\n\r\n        //\xe6\xa0\xb9\xe6\x8d\xae\xe7\x89\xa9\xe4\xbd\x93\xe6\x9d\x90\xe8\xb4\xa8\xe5\x86\xb3\xe5\xae\x9a\xe4\xb8\x8b\xe4\xb8\x80\xe6\x9d\xa1\xe5\x85\x89\xe7\xba\xbf\xe7\x9a\x84\xe6\x96\xb9\xe5\x90\x91\r\n        float p = rand();\r\n        //\xe9\x95\x9c\xe9\x9d\xa2\xe5\x8f\x8d\xe5\xb0\x84\r\n        if (p < hit.material.specularRate) {\r\n            //\xe9\x95\x9c\xe9\x9d\xa2\xe5\x8f\x8d\xe5\xb0\x84\r\n            vec3 ref = reflect(oldRay, hit.normal);\r\n            r.direction = normalize(mix(ref, r.direction, hit.material.specularRoughness));\r\n            tint[depth] = hit.material.specularTint;\r\n            type[depth] = 1;\r\n        } else if (hit.material.specularRate <= p && p <= hit.material.specularRate + hit.material.refractRate) {\r\n            //\xe6\x8a\x98\xe5\xb0\x84\r\n            vec3 ref = refract(oldRay, hit.normal, 1.0 / hit.material.refractIndex);\r\n            r.direction = normalize(mix(ref, -r.direction, hit.material.refractRoughness));\r\n            tint[depth] = hit.material.refractTint;\r\n            type[depth] = 2;\r\n        } else {\r\n            //\xe6\xbc\xab\xe5\x8f\x8d\xe5\xb0\x84\r\n            type[depth] = 0;\r\n        }\r\n    }\r\n\r\n    //\xe8\xae\xa1\xe7\xae\x97\xe7\xb4\xaf\xe7\xa7\xaf\xe9\xa2\x9c\xe8\x89\xb2\r\n    for (int i = depth - 1; i >= 0; i--) {\r\n        vec3 light = color[i + 1] * sqrt(cosine[i]);\r\n        if (type[i] > 0) {\r\n            color[i] = mix(color[i] * length(light), light, tint[i]);\r\n        } else {\r\n            color[i] *= light;\r\n        }\r\n    }\r\n\r\n    return color[0];\r\n}\r\n\r\nvoid main() {\r\n    //\xe5\x89\x8d\xe4\xb8\x80\xe5\xb8\xa7\r\n    vec2 pixel = position.xy * 0.5 + 0.5;\r\n    vec3 lastColor = texture2D(lastFrame, pixel).rgb;\r\n    if (frame >= maxFrame) {\r\n        FragColor = vec4(lastColor, 1.0);\r\n        return;\r\n    }\r\n\r\n    //\xe5\x88\x9d\xe5\xa7\x8b\xe5\x85\x89\xe7\xba\xbf\xe6\x96\xb9\xe5\x90\x91\xe4\xb8\xba\xe8\xa7\x86\xe7\x82\xb9\xe6\x8c\x87\xe5\x90\x91\xe5\x83\x8f\xe7\xb4\xa0\xe7\x82\xb9\xef\xbc\x8c\xe5\x8a\xa0\xe5\x85\xa5\xe9\x9a\x8f\xe6\x9c\xba\xe5\x81\x8f\xe7\xa7\xbb\xe9\x87\x8f\xe4\xbb\xa5\xe6\x8a\x97\xe9\x94\xaf\xe9\xbd\xbf\r\n    Ray r;\r\n    r.startPoint = eyePos;\r\n    vec3 screen = position;\r\n    float d = rand(), th = rand() * (2.0 * PI);\r\n    screen.x += (d * sin(th) - 0.5) * pixel2d.x;\r\n    screen.y += (d * cos(th) - 0.5) * pixel2d.y;\r\n    r.direction = normalize(screen - eyePos);\r\n\r\n    //\xe5\xbd\x93\xe5\x89\x8d\xe5\xb8\xa7\xe7\x9a\x84\xe5\x83\x8f\xe7\xb4\xa0\xe9\xa2\x9c\xe8\x89\xb2\xe5\x8a\xa0\xe4\xb8\x8a\xe5\x89\x8d\xe4\xb8\x80\xe5\xb8\xa7\xe7\x9a\x84\xe5\x83\x8f\xe7\xb4\xa0\xe9\xa2\x9c\xe8\x89\xb2\r\n    vec3 color = pathTracing(r, 6) * (2.0 * PI);\r\n    float rate = 1.0 / (frame + 1);\r\n    color = mix(lastColor, color, rate);\r\n    FragColor = vec4(color, 1.0);\r\n}"

#define render_frag "#version 330\n\nuniform bool finished;\nuniform int maxIter;\nuniform sampler2D frameBuffer[8];\n\nin vec3 position;\nout vec4 FragColor;\n\nvoid main() {\n    vec3 color = vec3(0.0);\n    vec2 pixel = position.xy * 0.5 + 0.5;\n    if (finished) {\n        for (int i = 0; i < maxIter; i++) {\n            color += texture2D(frameBuffer[i], pixel).rgb;\n        }\n        color /= maxIter;\n    } else {\n        color += texture2D(frameBuffer[0], pixel).rgb;\n    }\n    color = pow(color, vec3(1.0 / 2.2)); //\xe4\xbc\xbd\xe9\xa9\xac\xe6\xa0\xa1\xe6\xad\xa3\n    FragColor = vec4(color, 1.0);\n}"
